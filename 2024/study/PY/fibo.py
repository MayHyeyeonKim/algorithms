def fibo(x):
    if x == 1 or x == 2: #종료조건
        return 1
    return fibo(x-1) + fibo(x-2) #재귀적으로 호출되는 부분

print(fibo(4))

#피보나치 빅오: 2의n승
#단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 된다. n이 조금만 커져도 기하급수적으로 더 많은 수의 시간이 필요함.
#중복부분문제 생기니까 수행시간 측면에서 이런 부분들을 메모 해두면 좋갰자 -> 매모이제이션
#Memoization - 캐싱 Caching
#탑다운(메모이제이션, 하향식), 바텀업(반복문, 상향식)
#결과 저장용 리스트 - DP table
# 한번 계산된 결과 메모이제이션 위한 리스트 초기화



#피보나치 수열: 탑다운 다이나믹 프로그래밍
d = [0] * 100
def fibo(x):
    if x == 1 or x == 2: #종료조건
        return 1
    if d[x] != 0: #이미 계산한 적 있으면 그대로 반환
        return d[x] 
    d[x] = fibo(x-1) + fibo(x-2) #아직 계산하지 않은 문제라면 점화식에 따라 피보나치 결과 반환
    return d[x]

print(fibo(4))


#피보나치 수열: 바텀업 다이나믹 프로그래밍
d = [0] * 100 #dp테이블 초기화

d[1] = 1
d[2] = 2
n = 99 #첫 번째 피보나치 수와 두 번째 피보나치 수 1로 설정

for i in range(3, n+1): #피보나치 함수 반복문으로 구현
    d[i] = d[i-1] + d[i-2]
print(d[n])